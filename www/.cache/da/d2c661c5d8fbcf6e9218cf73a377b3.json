{"id":"../../node_modules/spinal-core-connectorjs_type/dist/connectorTS.js","dependencies":[{"name":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-core-connectorjs_type/dist/connectorTS.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-core-connectorjs_type/src/connectorTS.ts","includedInParent":true,"mtime":499162500000},{"name":"/home/spinalcom/Documents/spinal/maintainer/spinal-browser-maintainer/package.json","includedInParent":true,"mtime":1556188313517},{"name":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-core-connectorjs_type/package.json","includedInParent":true,"mtime":1555335943983}],"generated":{"js":"/* tslint:disable:variable-name  class-name */\n"},"sourceMaps":{"js":{"version":3,"file":"connectorTS.js","sourceRoot":"","sources":["../src/connectorTS.ts"],"names":[],"mappings":"AACA,8CAA8C","sourcesContent":["\n/* tslint:disable:variable-name  class-name */\n\ndeclare module 'spinal-core-connectorjs' {\n  class spinalCore {\n    public static _def: {\n      Model: typeof spinal.Model;\n      Str: typeof spinal.Str;\n      Bool: typeof spinal.Bool,\n      Val: typeof spinal.Val,\n      Lst: typeof spinal.Lst,\n      Directory: typeof spinal.Directory,\n      Vec: typeof spinal.Vec,\n      Path: typeof spinal.Path,\n      File: typeof spinal.File,\n      Ptr: typeof spinal.Ptr,\n      Choice: typeof spinal.Choice,\n      TypedArray: typeof spinal.TypedArray,\n      TypedArray_Int32: typeof spinal.TypedArray_Int32,\n      TypedArray_Float32: typeof spinal.TypedArray_Float32,\n      TypedArray_Float64: typeof spinal.TypedArray_Float64,\n      Process: typeof spinal.Process,\n      BindProcess: typeof spinal.BindProcess,\n    };\n    /**\n     * Function to intialize the session to SpinalHub\n     * ex: `http://168:JHGgcz45JKilmzknzelf65ddDadggftIO98P@localhost:7777/`\n     * @static\n     * @param {string} connectOpt URI to connect to the hub\n     * @returns {spinal.FileSystem}\n     * @memberof spinalCore\n     */\n    public static connect(connectOpt: string): spinal.FileSystem;\n    /**\n     * Store a model in the virtual filesystem in SpinalHub,\n     * **Store on an existing path does replace it (if the user have the rights)**\n     * @static\n     * @param {spinal.FileSystem} fs\n     * @param {spinal.Model} model\n     * @param {string} path\n     * @param {spinal.SpinalStoreCallBackSucess} callback_success\n     * @param {spinal.SpinalCallBackError} [callback_error]\n     * @memberof spinalCore\n     */\n    public static store(\n        fs: spinal.FileSystem, model: spinal.Model, path: string,\n        callback_success: spinal.SpinalStoreCallBackSucess,\n        callback_error?: spinal.SpinalCallBackError): void;\n    /**\n     * register models, required when ussing modules require/import\n     * @static\n     * @param {(typeof spinal.Model|typeof spinal.Model[])} modelList\n     * @memberof spinalCore\n     */\n    public static register_models(modelList: any): void;\n    /**\n     * loads a model from the file system\n     * @static\n     * @param {spinal.FileSystem} fs\n     * @param {string} path\n     * @param {spinal.SpinalLoadCallBackSucess} callback_success\n     * @param {spinal.SpinalCallBackError} [callback_error]\n     * @memberof spinalCore\n     */\n    public static load(\n        fs: spinal.FileSystem, path: string,\n        callback_success: spinal.SpinalLoadCallBackSucess,\n        callback_error?: spinal.SpinalCallBackError): void;\n    /**\n     * loads all the models of a specific type\n     * @static\n     * @param {spinal.FileSystem} fs\n     * @param {string} type\n     * @param {spinal.SpinalLoadTypeCallBackSucess} callback_success is called for each Model found\n     * @param {spinal.SpinalCallBackError} [callback_error]\n     * @memberof spinalCore\n     */\n    public static load_type(\n        fs: spinal.FileSystem, type: string,\n        callback_success: spinal.SpinalLoadTypeCallBackSucess,\n        callback_error?: spinal.SpinalCallBackError): void;\n    /**\n     * get the right of a model\n     * @static\n     * @param {spinal.FileSystem} fs\n     * @param {number} ptr\n     * @param {spinal.SpinalLoadCallBackSucess} callback_success\n     * @param {spinal.SpinalCallBackError} [callback_error]\n     * @memberof spinalCore\n     */\n    public static load_right(fs: spinal.FileSystem, ptr: number,\n                             callback_success: spinal.SpinalLoadCallBackSucess,\n                             callback_error?: spinal.SpinalCallBackError): void;\n\n    /**\n     * share a Model/File to another user\n     * @static\n     * @param {spinal.FileSystem} fs\n     * @param {number} ptr\n     * @param {string} file_name\n     * @param {number} right_flag\n     * @param {string} targetName\n     * @memberof spinalCore\n     */\n    public static share_model(\n        fs: spinal.FileSystem, ptr: number, file_name: string,\n        right_flag: number, targetName: string): void;\n    public static right_flag: {AD: 1; WR: 2; RD: 4; };\n    /**\n     * extend one object as a class, using the same 'class' concept as coffeescript\n     * @static\n     * @param {Function} child\n     * @param {Function} parent\n     * @memberof spinalCore\n     */\n    public static extend(child: Function, parent: Function): void;\n  }\n  namespace spinalCore {}\n\n  export = spinalCore;\n}\n\ndeclare namespace spinal {\n  type SpinalOnChangeBindModel = () => void;\n  type SpinalStoreCallBackSucess = () => void;\n  type SpinalCallBackError = () => void;\n  type SpinalLoadCallBackSucess = (model: Model) => void;\n  type SpinalLoadCallBack<T extends Model> = (model: T, error: boolean) => void;\n  type SpinalLoadTypeCallBackSucess = (model: Model) => void;\n  type SpinalFilterFunction = (item: Model) => boolean;\n  type SpinalSortFunction = (item1: Model, item2: Model) => number;\n\n  class Model {\n    [nameAttr: string]: any;\n    /**\n     *Creates an instance of Model.\n     * @param {{[nameAttr: string]: any}} [object]\n     * must be in a form `{ [nameAttr: string]: typeof Model, ... }`\n     * @memberof Model\n     */\n    constructor(object?: {[nameAttr: string]: any});\n    /**\n     * ### return a copy of data in a \"standard JS\" representation\n     * (e.g. string, number, objects, ...).\n     *\n     * Users are encouraged to use Models as much as possible\n     * (meaning that get should not be called for every manipulation),\n     * adding methods for manipulation of data if necessary\n     * (e.g. toggle, find, ... in Lst, Str, ...).\n     *\n     * _May be redefined for specific types (e.g. Str, Lst, ...)_\n     * @memberof Model\n     * @returns {*}\n     */\n    get(): any;\n    /**\n     * modify data, using another values, or Model instances.\n     * Should not be redefined (but _set should be)\n     *\n     * @param {*} opt\n     * @memberof Model\n     * @returns {boolean} returns true if the object is modified\n     */\n    set(opt: any): boolean;\n    /**\n     * add attribute\n     * @param {{[nameAttr: string]: any}} object\n     * must be in a form `{ [nameAttr: string]: typeof Model, ... }`\n     * @memberof Model\n     */\n    add_attr(object: {[nameAttr: string]: any}): void;\n    /**\n     * add attribute\n     * @param {string} name\n     * @param {*} [instanceOfModel]\n     * @param {boolean} [signal_change=true]\n     * @memberof Model\n     */\n    add_attr(name: string, instanceOfModel?: any, signal_change?: boolean): void;\n    /**\n     * change attribute named `name` to `opt` (use references for comparison)\n     * @param {string} name\n     * @param {*} opt\n     * @memberof Model\n     */\n    mod_attr(name: string, opt: any): void;\n    /**\n     * remove attribute named name\n     * @param {string} name\n     * @param {boolean} [signal_change=true]\n     * @memberof Model\n     */\n    rem_attr(name: string, signal_change?: boolean): void;\n    /**\n     * `add / mod / rem attr` to get the same data than `opt`\n     *  (assumed to be something like `{ key: val, ... }`)\n     * @param {object} opt\n     * @memberof Model\n     */\n    set_attr(opt: object): void;\n    /**\n     *  if this has been modified during the preceding round, f will be called\n     *\n     * @param {(Process|BindProcess|SpinalOnChangeBindModel)} f If f is a\n    process:\n      - process.onchange will be called each time this (or a child of this) will\n    be modified.\n      - process.destructor will be called if this is destroyed.\n     * @param {boolean} [onchange_construction=true] true means that onchange\n    will be automatically\n     * @returns {BindProcess}\n     * @memberof Model\n     */\n    bind(\n        f: Process|BindProcess|SpinalOnChangeBindModel,\n        onchange_construction?: boolean): BindProcess;\n    unbind(f: Process|BindProcess|SpinalOnChangeBindModel): void;\n    /**\n     * return true if this (or a child of this) has changed since the previous\n     * synchronisation\n     * @returns {boolean}\n     * @memberof Model\n     */\n    has_been_modified(): boolean;\n    /**\n     * return true if this has changed since previous synchronisation due to\n     * a direct modification (not from a child one)\n     * @returns {boolean}\n     * @memberof Model\n     */\n    has_been_directly_modified(): boolean;\n    /**\n     * create and returns a deep copy\n     * @returns {Model}\n     * @memberof Model\n     */\n    deep_copy(): Model;\n  }\n\n  class Obj extends Model {}\n\n  class Str extends Obj {\n    constructor(data?: Str|string);\n    length: number;\n    get(): string;\n    contains(str: string): boolean;\n    equals(str: Str|string): boolean;\n  }\n\n  class Bool extends Obj {\n    constructor(data?: boolean)\n    get(): boolean;\n    toggle(): void;\n    toBoolean(): boolean;\n  }\n\n  class Val extends Obj {\n    constructor(value?: number|Val|string|boolean)\n    get(): number;\n  }\n\n  /**\n   * vector of objects inherited from Model\n   * @class Lst\n   * @extends {Model}\n   */\n  class Lst<T extends Model> extends Model {\n    constructor(data?: any[]);\n    length: number;\n    get(): any[];\n    /**\n     * append value at the end of the list.\n     * @param {any} value\n     * @memberof Lst\n     */\n    push(value: any): void;\n    /**\n     * remove and return the last element\n     * @memberof Lst\n     * @returns {*}\n     */\n    pop(): any;\n    /**\n     * empty the Lst\n     * @memberof Lst\n     */\n    clear(): void;\n    /**\n     * add an element to the beginning of an array, return the new length\n     * @param {*} element\n     * @returns {number}\n     * @memberof Lst\n     */\n    unshift(element: any): number;\n    /**\n     * remove and return the first element\n     * @type null\n     * @memberof Lst\n     * @returns {*}\n     */\n    shift(): any;\n\n    /**\n     * remove item from the list id present\n     * @param {*} item\n     * @returns {*}\n     * @memberof Lst\n     */\n    remove(item: any): any;\n\n    /**\n     * remove item from the list id present, based on ref comparison\n     * @param {*} item\n     * @returns {*}\n     * @memberof Lst\n     */\n    remove_ref(item: any): any;\n\n    /**\n     * return a list with item such as f( item ) is true\n     * @param {SpinalFilterFunction} f\n     * @memberof Lst\n     */\n    filter(f: SpinalFilterFunction): void;\n    /**\n     * return the first item such as f( item ) is true. If not item, return\n     * undefined\n     * @param {SpinalFilterFunction} f\n     * @memberof Lst\n     */\n    detect(f: SpinalSortFunction): void;\n    /**\n     * sort item depending function and return a new Array\n     * @param {SpinalSortFunction} fun_sort\n     * @returns {any[]}\n     * @memberof Lst\n     */\n    sorted(fun_sort: SpinalSortFunction): any[];\n\n    /**\n     * return true if there is an item that checks f( item )\n     * @param {SpinalFilterFunction} func\n     * @returns {boolean}\n     * @memberof Lst\n     */\n    has(func: SpinalFilterFunction): boolean;\n\n    /**\n     * returns index of v if v is present in the list. Else, return -1\n     * @param {*} value\n     * @returns {number}\n     * @memberof Lst\n     */\n    indexOf(value: any): number;\n\n    /**\n     * returns index of v if v is present in the list, based on ref comparison.\n     * Else, return -1\n     * @param {*} value\n     * @memberof Lst\n     * @returns {number}\n     */\n    indexOf_ref(value: any): number;\n\n    /**\n     * @param {*} value\n     * @returns {boolean}\n     * @memberof Lst\n     */\n    contains(value: any): boolean;\n\n    /**\n     * @param {*} value\n     * @returns {boolean}\n     * @memberof Lst\n     */\n    contains_ref(value: any): boolean;\n\n    /**\n     * toggle presence of v. return true if added\n     * @param {*} value\n     * @returns {boolean}\n     * @memberof Lst\n     */\n    toggle(value: any): boolean;\n\n    /**\n     * toggle presence of v, base on ref comparison\n     * @param {*} value\n     * @returns {boolean}\n     * @memberof Lst\n     */\n    toggle_ref(value: any): boolean;\n\n    /**\n     * return a new lst between begin and end index\n     * @param {number} begin\n     * @param {number} [end]\n     * @returns {Lst}\n     * @memberof Lst\n     */\n    slice(begin: number, end?: number): Lst<T>;\n\n    /**\n     * return list with new_tab after\n     * @param {Lst} new_lst\n     * @param {boolean} [force]\n     * @returns {Lst}\n     * @memberof Lst\n     */\n    concat(new_lst: Lst<T>|T[], force?: boolean): Lst<T>;\n\n    /**\n     * remove n items from index\n     * @param {number} index\n     * @param {number} [n=1]\n     * @memberof Lst\n     */\n    splice(index: number, n?: number): void;\n\n    /**\n     * Insert a Lst in the index\n     * @param {number} index\n     * @param {(T[]|Lst<T>|any[]|Lst<any>)} list\n     * @memberof Lst\n     */\n    insert(index: number, list: T[]|Lst<T>|any[]|Lst<any>): void;\n\n    /**\n     * permits to set an item or to grow the list if index == length\n     * @param {number} index\n     * @param {*} value\n     * @memberof Lst\n     */\n    set_or_push(index: number, value: any): void;\n\n    /**\n     * reduce the size\n     * @param {number} size\n     * @memberof Lst\n     */\n    trim(size: number): void;\n\n    /**\n     * return a string with representation of items, separated by separator\n     * @param {string} separator\n     * @returns {string}\n     * @memberof Lst\n     */\n    join(separator: string): string;\n\n    /**\n     * last element\n     * @returns {any}\n     * @memberof Lst\n     */\n    back(): any;\n  }\n  class Vec extends Lst<Val> {}\n  class Directory<T extends Model> extends Lst<File<T>> {\n    find(name: string): File<T>|undefined;\n    load(name: string, callBack: SpinalLoadCallBack<Model>): void;\n    add_file(name: string, obj: Model, params?: object): File<T>;\n    force_add_file(name: string, obj: Model, params?: object): File<T>;\n  }\n  class Path extends Model {\n    /**\n     *Creates an instance of Path.\n     * @param {File} file A real File\n     * @memberof Path\n     */\n    constructor(file?: any);\n    remaining: number;\n    to_upload: number;\n  }\n  class File<T extends Model> extends Model {\n    name: Str;\n    _ptr: Ptr<T>;\n    _info: Model;\n    constructor(name: string, ptr_or_model:number|Model|Ptr<any>, info: Model|Object);\n    load(callback: SpinalLoadCallBack<T>): void;\n  }\n  class Ptr<T extends Model> extends Model {\n    constructor(model?: T|number);\n    data: {model?: T, value?: number};\n    load(callback: SpinalLoadCallBack<T>): void;\n  }\n  class Pbr<T extends Model> extends Ptr<T> {}\n  class Choice extends Model {\n    num: Val;\n    lst: Lst<Str>;\n    constructor(InitIdx?: Val|number, stringChoises?: (string|Str)[]);\n  }\n  class TypedArray<T extends Int32Array|Float32Array|Float64Array> extends Model {\n    constructor(size?: number, data?: any[]);\n    dim(): number;\n    size(d?: number): number;\n    set_val(index: number[]|number, value: any): void;\n    nb_items(): number;\n    equals(obj: any): boolean;\n    resize(new_size: number[]): void;\n    base_type(): void;\n    get(): T;\n    get(index : number | number[]): number;\n    base_type(): T;\n    toString(): void;\n  }\n  class TypedArray_Int32 extends TypedArray<Int32Array> {\n    base_type(): Int32Array;\n  }\n  class TypedArray_Float32 extends TypedArray<Float32Array>  {\n    base_type(): Float32Array;\n  }\n  class TypedArray_Float64 extends TypedArray<Float64Array>  {\n    base_type(): Float64Array;\n  }\n  class Process {\n    constructor(m: Model, onchange_construction?: boolean);\n    destructor(): void;\n    onchange(): void;\n  }\n  class BindProcess extends Process {\n    constructor(\n        m: Model, onchange_construction: boolean, f: SpinalOnChangeBindModel);\n  }\n  /**\n   * handle the connection between the SpinalHub and the Organ\n   * @class FileSystem\n   */\n  class FileSystem {\n    constructor();\n    load<T extends Model>(path: string, callback: SpinalLoadCallBack<T>): void;\n    load_type<T extends Model>(type: string, callback: SpinalLoadCallBack<Model>): void;\n    load_or_make_dir<T extends Model>(dir: string,\n                                      callback: SpinalLoadCallBack<Directory<T>>): void;\n    load_ptr<T extends Model>(ptr: number, callback: SpinalLoadCallBack<T>): void;\n    load_right<T extends Model>(ptr: number, callback: SpinalLoadCallBack<T>): void;\n    share_model(\n        ptr: number, file_name: string, share_type: number,\n        targetName: string): void;\n    public static get_inst(): FileSystem;\n    public static extend(child: any, parent: any): void;\n    public static debug: boolean;\n    public static _sig_server: boolean;\n    public static _disp: boolean;\n    public static CONNECTOR_TYPE: 'Node'|'Browser';\n    public static _objects: {[key: number]: Model};\n    public static _tmp_objects: {[key: number]: Model};\n  }\n}\n"]}},"error":null,"hash":"3350c5e89f1d9561631835bb16a64b63","cacheData":{"env":{}}}