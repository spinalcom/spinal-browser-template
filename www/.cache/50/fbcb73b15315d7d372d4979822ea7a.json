{"id":"../../node_modules/spinal-env-viewer-context-geographic-service/build/index.js","dependencies":[{"name":"/home/spinalcom/Documents/spinal/maintainer/spinal-browser-maintainer/package.json","includedInParent":true,"mtime":1556188313517},{"name":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-env-viewer-context-geographic-service/package.json","includedInParent":true,"mtime":1555411428200},{"name":"spinal-env-viewer-graph-service","loc":{"line":7,"column":43},"parent":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-env-viewer-context-geographic-service/build/index.js","resolved":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-env-viewer-graph-service/dist/index.js"},{"name":"spinal-models-building-elements","loc":{"line":9,"column":44},"parent":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-env-viewer-context-geographic-service/build/index.js","resolved":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-models-building-elements/build/index.js"},{"name":"spinal-env-viewer-plugin-bimobjectservice","loc":{"line":11,"column":53},"parent":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-env-viewer-context-geographic-service/build/index.js","resolved":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-env-viewer-plugin-bimobjectservice/build/createGraphBimObject.js"},{"name":"./constants","loc":{"line":15,"column":25},"parent":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-env-viewer-context-geographic-service/build/index.js","resolved":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-env-viewer-context-geographic-service/build/constants.js"},{"name":"spinal-core-connectorjs_type","loc":{"line":19,"column":42},"parent":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-env-viewer-context-geographic-service/build/index.js","resolved":"/home/spinalcom/Documents/spinal/maintainer/node_modules/spinal-core-connectorjs_type/dist/SpinalModel.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _spinalEnvViewerGraphService = require(\"spinal-env-viewer-graph-service\");\n\nvar _spinalModelsBuildingElements = require(\"spinal-models-building-elements\");\n\nvar _spinalEnvViewerPluginBimobjectservice = require(\"spinal-env-viewer-plugin-bimobjectservice\");\n\nvar _spinalEnvViewerPluginBimobjectservice2 = _interopRequireDefault(_spinalEnvViewerPluginBimobjectservice);\n\nvar _constants = require(\"./constants\");\n\nvar constants = _interopRequireWildcard(_constants);\n\nvar _spinalCoreConnectorjs_type = require(\"spinal-core-connectorjs_type\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst GeographicContext = {\n  constants: constants,\n\n  /**\n   * Returns the child type of the type given as parameter.\n   * @param {string} parentType\n   * @return {string} Child type\n   */\n  getChildType(parentType) {\n    let parentTypeIndex = constants.GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);\n\n    if (parentTypeIndex === -1) {\n      return \"\";\n    }\n\n    return constants.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];\n  },\n\n  /**\n   * It Takes as parameter a context name, returns true if a context with the same name does not exist, else returns false.\n   * @param {string} contextName\n   * @returns {Boolean}\n   */\n  createContext(contextName) {\n    if (typeof contextName !== \"string\") {\n      throw Error(\"contextName must be a string\");\n    }\n\n    const context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(contextName);\n\n    if (typeof context !== \"undefined\") return false;\n\n    _spinalEnvViewerGraphService.SpinalGraphService.addContext(contextName, constants.CONTEXT_TYPE, new _spinalModelsBuildingElements.AbstractElement(contextName));\n\n    return true;\n  },\n\n  /**\n   * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} elementName - The AbstactElement Name\n   * @returns {Boolean}\n   */\n  addAbstractElement(context, node, elementName) {\n    const parentType = node.type.get();\n    const childType = this.getChildType(parentType);\n\n    if (!childType) {\n      throw Error(`${parentType} is not a valid type in geographical context`);\n    }\n\n    const childRelation = constants.MAP_TYPE_RELATION.get(childType);\n\n    const childNode = _spinalEnvViewerGraphService.SpinalGraphService.createNode({\n      name: elementName,\n      type: childType\n    }, new _spinalModelsBuildingElements.AbstractElement(elementName));\n    _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(node.id.get(), childNode, context.id.get(), childRelation, _spinalEnvViewerGraphService.SPINAL_RELATION_TYPE);\n\n    this.addToReferenceContext(childNode);\n\n    return true;\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} buildingName - Building Name\n   */\n  addBuilding(context, node, buildingName) {\n    return GeographicContext.addAbstractElement(context, node, buildingName);\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} floorName - the floor Name\n   */\n  addFloor(context, node, floorName) {\n    return GeographicContext.addAbstractElement(context, node, floorName);\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} zoneName - Zone name\n   */\n  addZone(context, node, zoneName) {\n    return GeographicContext.addAbstractElement(context, node, zoneName);\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} roomName - Room Name\n   */\n  addRoom(context, node, roomName) {\n    return GeographicContext.addAbstractElement(context, node, roomName);\n  },\n\n  /**\n   * it uses bimObject service to add all dbIds passed as parameters.\n   * the parameter dbIds can be a simple dbIds or a list of dbIds.\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {Number | Array<Number>} dbIds - Can be\n   */\n  addBimElement(context, node, dbIds) {\n    if (!Array.isArray(dbIds)) dbIds = [dbIds];\n\n    // le bimObjectService\n    let c = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(context.id.get());\n    let n = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(node.id.get());\n\n    dbIds.forEach(element => {\n      _spinalEnvViewerPluginBimobjectservice2.default.addBIMObject(c, n, element.dbId, element.name);\n    });\n  },\n\n  _getReferenceContextName(nodeId) {\n    let node = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(nodeId);\n\n    switch (node.type.get()) {\n      case constants.SITE_TYPE:\n        return {\n          name: constants.SITE_REFERENCE_CONTEXT,\n          relation: constants.SITE_RELATION\n        };\n      case constants.BUILDING_TYPE:\n        return {\n          name: constants.BUILDING_REFERENCE_CONTEXT,\n          relation: constants.BUILDING_RELATION\n        };\n\n      case constants.FLOOR_TYPE:\n        return {\n          name: constants.FLOOR_REFERENCE_CONTEXT,\n          relation: constants.FLOOR_RELATION\n        };\n\n      case constants.ZONE_TYPE:\n        return {\n          name: constants.ZONE_REFERENCE_CONTEXT,\n          relation: constants.ZONE_RELATION\n        };\n\n      case constants.ROOM_TYPE:\n        return {\n          name: constants.ROOM_REFERENCE_CONTEXT,\n          relation: constants.ROOM_RELATION\n        };\n\n      default:\n        return undefined;\n    }\n  },\n\n  /**\n   *\n   * @param {string} nodeId\n   */\n  addToReferenceContext(nodeId) {\n    let obj = this._getReferenceContextName(nodeId);\n\n    if (typeof obj !== \"undefined\") {\n      let context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(obj.name);\n\n      if (typeof context !== \"undefined\") {\n\n        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(context.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);\n      }\n\n      return _spinalEnvViewerGraphService.SpinalGraphService.addContext(obj.name, obj.name.replace(\".\", \"\"), new _spinalCoreConnectorjs_type.Model({\n        name: obj.name\n      })).then(c => {\n        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(c.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);\n      });\n    }\n  },\n\n  /**\n   *\n   * @param {string} contextId\n   */\n  addContextToReference(contextId) {\n    let context = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(contextId);\n\n    if (typeof context !== \"undefined\") {\n      return context.forEach(constants.GEOGRAPHIC_RELATIONS, node => {\n        _spinalEnvViewerGraphService.SpinalGraphService._addNode(node);\n        this.addToReferenceContext(node.info.id.get());\n      });\n    }\n  }\n\n};\n\nexports.default = GeographicContext;\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/index.js"],"names":["constants","GeographicContext","getChildType","parentType","parentTypeIndex","GEOGRAPHIC_TYPES_ORDER","indexOf","createContext","contextName","Error","context","SpinalGraphService","getContext","addContext","CONTEXT_TYPE","AbstractElement","addAbstractElement","node","elementName","type","get","childType","childRelation","MAP_TYPE_RELATION","childNode","createNode","name","addChildInContext","id","SPINAL_RELATION_TYPE","addToReferenceContext","addBuilding","buildingName","addFloor","floorName","addZone","zoneName","addRoom","roomName","addBimElement","dbIds","Array","isArray","c","getRealNode","n","forEach","element","bimobjService","addBIMObject","dbId","_getReferenceContextName","nodeId","getInfo","SITE_TYPE","SITE_REFERENCE_CONTEXT","relation","SITE_RELATION","BUILDING_TYPE","BUILDING_REFERENCE_CONTEXT","BUILDING_RELATION","FLOOR_TYPE","FLOOR_REFERENCE_CONTEXT","FLOOR_RELATION","ZONE_TYPE","ZONE_REFERENCE_CONTEXT","ZONE_RELATION","ROOM_TYPE","ROOM_REFERENCE_CONTEXT","ROOM_RELATION","undefined","obj","addChild","info","SPINAL_RELATION_LST_PTR_TYPE","replace","Model","then","addContextToReference","contextId","GEOGRAPHIC_RELATIONS","_addNode"],"mappings":"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","file":"index.js","sourcesContent":["import {\n  SPINAL_RELATION_TYPE,\n  SPINAL_RELATION_LST_PTR_TYPE,\n  SpinalGraphService\n} from \"spinal-env-viewer-graph-service\";\nimport {\n  AbstractElement\n} from \"spinal-models-building-elements\";\nimport bimobjService from 'spinal-env-viewer-plugin-bimobjectservice';\n\nimport * as constants from \"./constants\";\nimport {\n  Model\n} from \"spinal-core-connectorjs_type\";\n\nconst GeographicContext = {\n  constants: constants,\n\n  /**\n   * Returns the child type of the type given as parameter.\n   * @param {string} parentType\n   * @return {string} Child type\n   */\n  getChildType(parentType) {\n    let parentTypeIndex = constants.GEOGRAPHIC_TYPES_ORDER.indexOf(\n    parentType);\n\n    if (parentTypeIndex === -1) {\n      return \"\";\n    }\n\n    return constants.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];\n  },\n\n  /**\n   * It Takes as parameter a context name, returns true if a context with the same name does not exist, else returns false.\n   * @param {string} contextName\n   * @returns {Boolean}\n   */\n  createContext(contextName) {\n    if (typeof contextName !== \"string\") {\n      throw Error(\n        \"contextName must be a string\");\n    }\n\n    const context = SpinalGraphService.getContext(contextName);\n\n    if (typeof context !== \"undefined\") return false;\n\n\n    SpinalGraphService.addContext(contextName,\n      constants.CONTEXT_TYPE,\n      new AbstractElement(contextName));\n\n    return true;\n  },\n\n  /**\n   * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} elementName - The AbstactElement Name\n   * @returns {Boolean}\n   */\n  addAbstractElement(context, node, elementName) {\n    const parentType = node.type.get();\n    const childType = this.getChildType(parentType);\n\n    if (!childType) {\n      throw Error(\n        `${parentType} is not a valid type in geographical context`\n      );\n    }\n\n    const childRelation = constants.MAP_TYPE_RELATION.get(childType);\n\n    const childNode = SpinalGraphService.createNode({\n        name: elementName,\n        type: childType\n      },\n      new AbstractElement(elementName)\n    );\n    SpinalGraphService.addChildInContext(node.id.get(), childNode, context.id\n      .get(), childRelation, SPINAL_RELATION_TYPE);\n\n    this.addToReferenceContext(childNode);\n\n    return true;\n  },\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} buildingName - Building Name\n   */\n  addBuilding(context, node, buildingName) {\n    return GeographicContext.addAbstractElement(context, node, buildingName);\n  },\n\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} floorName - the floor Name\n   */\n  addFloor(context, node, floorName) {\n    return GeographicContext.addAbstractElement(context, node, floorName);\n  },\n\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} zoneName - Zone name\n   */\n  addZone(context, node, zoneName) {\n    return GeographicContext.addAbstractElement(context, node, zoneName);\n  },\n\n\n  /**\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {string} roomName - Room Name\n   */\n  addRoom(context, node, roomName) {\n    return GeographicContext.addAbstractElement(context, node, roomName);\n  },\n\n  /**\n   * it uses bimObject service to add all dbIds passed as parameters.\n   * the parameter dbIds can be a simple dbIds or a list of dbIds.\n   * @param {SpinalContext} context - The Context geographic\n   * @param {SpinalNode} node - The parent Node\n   * @param {Number | Array<Number>} dbIds - Can be\n   */\n  addBimElement(context, node, dbIds) {\n    if (!Array.isArray(dbIds)) dbIds = [dbIds];\n\n\n    // le bimObjectService\n    let c = SpinalGraphService.getRealNode(context.id.get());\n    let n = SpinalGraphService.getRealNode(node.id.get());\n\n    dbIds.forEach(element => {\n      bimobjService.addBIMObject(c, n, element.dbId, element.name);\n    });\n  },\n\n\n  _getReferenceContextName(nodeId) {\n    let node = SpinalGraphService.getInfo(nodeId);\n\n    switch (node.type.get()) {\n      case constants.SITE_TYPE:\n        return {\n          name: constants.SITE_REFERENCE_CONTEXT,\n          relation: constants.SITE_RELATION\n        };\n      case constants.BUILDING_TYPE:\n        return {\n          name: constants.BUILDING_REFERENCE_CONTEXT,\n          relation: constants.BUILDING_RELATION\n        };\n\n      case constants.FLOOR_TYPE:\n        return {\n          name: constants.FLOOR_REFERENCE_CONTEXT,\n          relation: constants.FLOOR_RELATION\n        };\n\n      case constants.ZONE_TYPE:\n        return {\n          name: constants.ZONE_REFERENCE_CONTEXT,\n          relation: constants.ZONE_RELATION\n        };\n\n      case constants.ROOM_TYPE:\n        return {\n          name: constants.ROOM_REFERENCE_CONTEXT,\n          relation: constants.ROOM_RELATION\n        };\n\n      default:\n        return undefined;\n    }\n  },\n\n  /**\n   *\n   * @param {string} nodeId\n   */\n  addToReferenceContext(nodeId) {\n    let obj = this._getReferenceContextName(nodeId);\n\n    if (typeof obj !== \"undefined\") {\n      let context = SpinalGraphService.getContext(obj.name);\n\n      if (typeof context !== \"undefined\") {\n\n        return SpinalGraphService.addChild(context.info.id.get(), nodeId,\n          obj.relation,\n          SPINAL_RELATION_LST_PTR_TYPE);\n      }\n\n      return SpinalGraphService.addContext(obj.name, obj.name.replace(\n        \".\", \"\"), new Model({\n        name: obj.name\n      })).then(c => {\n        return SpinalGraphService.addChild(c.info.id.get(), nodeId,\n          obj.relation,\n          SPINAL_RELATION_LST_PTR_TYPE);\n      });\n\n\n    }\n\n  },\n\n  /**\n   *\n   * @param {string} contextId\n   */\n  addContextToReference(contextId) {\n    let context = SpinalGraphService.getRealNode(contextId);\n\n    if (typeof context !== \"undefined\") {\n      return context.forEach(constants.GEOGRAPHIC_RELATIONS, (node) => {\n        SpinalGraphService._addNode(node);\n        this.addToReferenceContext(node.info.id.get());\n      })\n    }\n\n  }\n\n};\n\nexport default GeographicContext;"]}},"error":null,"hash":"98e852ad4ebafb8f7e07a5839ea05340","cacheData":{"env":{}}}